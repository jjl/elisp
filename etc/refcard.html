<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<meta name="generator" content=
"HTML Tidy for Linux/x86 (vers 1st October 2002), see www.w3.org">
<title>refcard.dvi</title>
<meta http-equiv="Content-Type" content=
"text/html; charset=Latin1">
<meta name="GENERATOR" content="pdftohtml 0.34">
<style type="text/css">
 body {
  background-color: #A0A0A0;
 }
 :link { color: blue }
 :visited { color: blue }
</style>
</head>
<body>
<a name="1"></a>GNU Emacs Reference Card<br>
(for version 21)<br>
Starting Emacs<br>
To enter GNU Emacs 21, just type its name: emacs<br>
To read in a file to edit, see Files, below.<br>
Leaving Emacs<br>
suspend Emacs (or iconify it under X)<br>
C-z<br>
exit Emacs permanently<br>
C-x C-c<br>
Files<br>
read<br>
a file into Emacs<br>
C-x C-f<br>
save<br>
a file back to disk<br>
C-x C-s<br>
save all files<br>
C-x s<br>
insert<br>
contents of another file into this buffer<br>
C-x i<br>
replace this file with the file you really want<br>
C-x C-v<br>
write buffer to a specified file<br>
C-x C-w<br>
version control checkin/checkout<br>
C-x C-q<br>
Getting Help<br>
The help system is simple. Type C-h (or F1) and follow the
direc-<br>
tions. If you are a first-time user, type C-h t for a tutorial.<br>
remove help window<br>
C-x 1<br>
scroll help window<br>
C-M-v<br>
apropos: show commands matching a string<br>
C-h a<br>
show the function a key runs<br>
C-h c<br>
describe a function<br>
C-h f<br>
get mode-specific information<br>
C-h m<br>
Error Recovery<br>
abort<br>
partially typed or executing command<br>
C-g<br>
recover<br>
a file lost by a system crash<br>
M-x recover-file<br>
undo<br>
an unwanted change<br>
C-x u<br>
or C-_<br>
restore a buffer to its original contents<br>
M-x revert-buffer<br>
redraw garbaged screen<br>
C-l<br>
Incremental Search<br>
search forward<br>
C-s<br>
search backward<br>
C-r<br>
regular expression search<br>
C-M-s<br>
reverse regular expression search<br>
C-M-r<br>
select previous search string<br>
M-p<br>
select next later search string<br>
M-n<br>
exit incremental search<br>
RET<br>
undo effect of last character<br>
DEL<br>
abort current search<br>
C-g<br>
Use C-s or C-r again to repeat the search in either direction.
If<br>
Emacs is still searching, C-g cancels only the part not done.<br>
c 1997 Free Software Foundation, Inc. Permissions on back. v2.2<br>
1<br>
<a name="2"></a>Motion<br>
entity to move over<br>
backward<br>
forward<br>
character<br>
C-b<br>
C-f<br>
word<br>
M-b<br>
M-f<br>
line<br>
C-p<br>
C-n<br>
go to line beginning (or end)<br>
C-a<br>
C-e<br>
sentence<br>
M-a<br>
M-e<br>
paragraph<br>
M-{<br>
M-}<br>
page<br>
C-x [<br>
C-x ]<br>
sexp<br>
C-M-b<br>
C-M-f<br>
function<br>
C-M-a<br>
C-M-e<br>
go to buffer beginning (or end)<br>
M-&lt;<br>
M-&gt;<br>
scroll to next screen<br>
C-v<br>
scroll to previous screen<br>
M-v<br>
scroll left<br>
C-x &lt;<br>
scroll right<br>
C-x &gt;<br>
scroll current line to center of screen<br>
C-u C-l<br>
Killing and Deleting<br>
entity to kill<br>
backward<br>
forward<br>
character (delete, not kill)<br>
DEL<br>
C-d<br>
word<br>
M-DEL<br>
M-d<br>
line (to end of)<br>
M-0 C-k<br>
C-k<br>
sentence<br>
C-x DEL<br>
M-k<br>
sexp<br>
M-- C-M-k<br>
C-M-k<br>
kill region<br>
C-w<br>
copy region to kill ring<br>
M-w<br>
kill through next occurrence of char<br>
M-z char<br>
yank back last thing killed<br>
C-y<br>
replace last yank with previous kill<br>
M-y<br>
Marking<br>
set mark here<br>
C-@<br>
or C-SPC<br>
exchange point and mark<br>
C-x C-x<br>
set mark arg words away<br>
M-@<br>
mark paragraph<br>
M-h<br>
mark page<br>
C-x C-p<br>
mark sexp<br>
C-M-@<br>
mark function<br>
C-M-h<br>
mark entire buffer<br>
C-x h<br>
Query Replace<br>
interactively replace a text string<br>
M-%<br>
using regular expressions<br>
M-x query-replace-regexp<br>
Valid responses in query-replace mode are<br>
replace<br>
this one, go on to next<br>
SPC<br>
replace this one, don't move<br>
,<br>
skip<br>
to next without replacing<br>
DEL<br>
replace all remaining matches<br>
!<br>
back up<br>
to the previous match<br>
^<br>
exit<br>
query-replace<br>
RET<br>
enter recursive edit (C-M-c to exit)<br>
C-r<br>
2<br>
<a name="3"></a>Multiple Windows<br>
When two commands are shown, the second is for "other frame."<br>
delete all other windows<br>
C-x 1<br>
split window, above and below<br>
C-x 2<br>
C-x 5 2<br>
delete this window<br>
C-x 0<br>
C-x 5 0<br>
split window, side by side<br>
C-x 3<br>
scroll other window<br>
C-M-v<br>
switch cursor to another window<br>
C-x o<br>
C-x 5 o<br>
select buffer in other window<br>
C-x 4 b<br>
C-x 5 b<br>
display buffer in other window<br>
C-x 4 C-o<br>
C-x 5 C-o<br>
find file in other window<br>
C-x 4 f<br>
C-x 5 f<br>
find file read-only in other window<br>
C-x 4 r<br>
C-x 5 r<br>
run Dired in other window<br>
C-x 4 d<br>
C-x 5 d<br>
find tag in other window<br>
C-x 4 .<br>
C-x 5 .<br>
grow window taller<br>
C-x ^<br>
shrink window narrower<br>
C-x {<br>
grow window wider<br>
C-x }<br>
Formatting<br>
indent current line (mode-dependent)<br>
TAB<br>
indent region (mode-dependent)<br>
C-M-\<br>
indent sexp (mode-dependent)<br>
C-M-q<br>
indent region rigidly arg columns<br>
C-x TAB<br>
insert newline after point<br>
C-o<br>
move rest of line vertically down<br>
C-M-o<br>
delete blank lines around point<br>
C-x C-o<br>
join line with previous (with arg, next)<br>
M-^<br>
delete all white space around point<br>
M-\<br>
put exactly one space at point<br>
M-SPC<br>
fill paragraph<br>
M-q<br>
set fill column<br>
C-x f<br>
set prefix each line starts with<br>
C-x .<br>
set face<br>
M-g<br>
Case Change<br>
uppercase word<br>
M-u<br>
lowercase word<br>
M-l<br>
capitalize word<br>
M-c<br>
uppercase region<br>
C-x C-u<br>
lowercase region<br>
C-x C-l<br>
The Minibuffer<br>
The following keys are defined in the minibuffer.<br>
complete as much as possible<br>
TAB<br>
complete up to one word<br>
SPC<br>
complete and execute<br>
RET<br>
show possible completions<br>
?<br>
fetch previous minibuffer input<br>
M-p<br>
fetch later minibuffer input or default<br>
M-n<br>
regexp search backward through history<br>
M-r<br>
regexp search forward through history<br>
M-s<br>
abort command<br>
C-g<br>
Type C-x ESC ESC to edit and repeat the last command that used<br>
the minibuffer. Type F10 to activate the menu bar using the
mini-<br>
buffer.<br>
3<br>
<a name="4"></a>GNU Emacs Reference Card<br>
Buffers<br>
select another buffer<br>
C-x b<br>
list all buffers<br>
C-x C-b<br>
kill a buffer<br>
C-x k<br>
Transposing<br>
transpose characters<br>
C-t<br>
transpose words<br>
M-t<br>
transpose lines<br>
C-x C-t<br>
transpose sexps<br>
C-M-t<br>
Spelling Check<br>
check spelling of current word<br>
M-$<br>
check spelling of all words in region<br>
M-x ispell-region<br>
check spelling of entire buffer<br>
M-x ispell-buffer<br>
Tags<br>
find a tag (a definition)<br>
M-.<br>
find next occurrence of tag<br>
C-u M-.<br>
specify a new tags file<br>
M-x visit-tags-table<br>
regexp search on all files in tags table<br>
M-x tags-search<br>
run query-replace on all the files<br>
M-x tags-query-replace<br>
continue last tags search or query-replace<br>
M-,<br>
Shells<br>
execute a shell command<br>
M-!<br>
run a shell command on the region<br>
M-|<br>
filter region through a shell command<br>
C-u M-|<br>
start a shell in window *shell*<br>
M-x shell<br>
Rectangles<br>
copy rectangle to register<br>
C-x r r<br>
kill rectangle<br>
C-x r k<br>
yank rectangle<br>
C-x r y<br>
open rectangle, shifting text right<br>
C-x r o<br>
blank out rectangle<br>
C-x r c<br>
prefix each line with a string<br>
C-x r t<br>
Abbrevs<br>
add global abbrev<br>
C-x a g<br>
add mode-local abbrev<br>
C-x a l<br>
add global expansion for this abbrev<br>
C-x a i g<br>
add mode-local expansion for this abbrev<br>
C-x a i l<br>
explicitly expand abbrev<br>
C-x a e<br>
expand previous word dynamically<br>
M-/<br>
4<br>
<a name="5"></a>Regular Expressions<br>
any single character except a newline<br>
.<br>
(dot)<br>
zero or more repeats<br>
*<br>
one or more repeats<br>
+<br>
zero or one repeat<br>
?<br>
quote regular expression special character c<br>
\c<br>
alternative ("or")<br>
\|<br>
grouping<br>
\( . . . \)<br>
same text as nth group<br>
\n<br>
at word break<br>
\b<br>
not at word break<br>
\B<br>
entity<br>
match start<br>
match end<br>
line<br>
^<br>
$<br>
word<br>
\&lt;<br>
\&gt;<br>
buffer<br>
\`<br>
\'<br>
class of characters<br>
match these<br>
match others<br>
explicit set<br>
[ . . . ]<br>
[^ . . . ]<br>
word-syntax character<br>
\w<br>
\W<br>
character with syntax c<br>
\sc<br>
\Sc<br>
International Character Sets<br>
specify principal language<br>
M-x set-language-environment<br>
show all input methods<br>
M-x list-input-methods<br>
enable or disable input method<br>
C-\<br>
set coding system for next command<br>
C-x RET c<br>
show all coding systems<br>
M-x list-coding-systems<br>
choose preferred coding system<br>
M-x prefer-coding-system<br>
Info<br>
enter the Info documentation reader<br>
C-h i<br>
find specified function or variable in Info<br>
C-h C-i<br>
Moving within a node:<br>
scroll forward<br>
SPC<br>
scroll reverse<br>
DEL<br>
beginning of node<br>
.<br>
(dot)<br>
Moving between nodes:<br>
next<br>
node<br>
n<br>
previous<br>
node<br>
p<br>
move up<br>
u<br>
select menu item by name<br>
m<br>
select nth menu item by number (1&shy;9)<br>
n<br>
follow cross reference (return with l)<br>
f<br>
return to last node you saw<br>
l<br>
return to directory node<br>
d<br>
go to any node by name<br>
g<br>
Other:<br>
run Info tutorial<br>
h<br>
quit<br>
Info<br>
q<br>
search nodes for regexp<br>
M-s<br>
5<br>
<a name="6"></a>Registers<br>
save region in register<br>
C-x r s<br>
insert register contents into buffer<br>
C-x r i<br>
save value of point in register<br>
C-x r SPC<br>
jump to point saved in register<br>
C-x r j<br>
Keyboard Macros<br>
start<br>
defining a keyboard macro<br>
C-x (<br>
end<br>
keyboard macro definition<br>
C-x )<br>
execute<br>
last-defined keyboard macro<br>
C-x e<br>
append to last keyboard macro<br>
C-u C-x (<br>
name last keyboard macro<br>
M-x name-last-kbd-macro<br>
insert Lisp definition in buffer<br>
M-x insert-kbd-macro<br>
Commands Dealing with Emacs Lisp<br>
eval sexp before point<br>
C-x C-e<br>
eval current defun<br>
C-M-x<br>
eval region<br>
M-x eval-region<br>
read and eval minibuffer<br>
M-:<br>
load from standard system directory<br>
M-x load-library<br>
Simple Customization<br>
customize variables and faces<br>
M-x customize<br>
Making global key bindings in Emacs Lisp (examples):<br>
(global-set-key "\C-cg" 'goto-line)<br>
(global-set-key "\M-#" 'query-replace-regexp)<br>
Writing Commands<br>
(defun command-name (args)<br>
"documentation" (interactive "template")<br>
body)<br>
An example:<br>
(defun this-line-to-top-of-window (line)<br>
"Reposition line point is on to top of window.<br>
With ARG, put point on line ARG."<br>
(interactive "P")<br>
(recenter (if (null line)<br>
0<br>
(prefix-numeric-value line))))<br>
The interactive spec says how to read arguments interactively.<br>
Type C-h f interactive for more details.<br>
Copyright c 1997 Free Software Foundation, Inc.<br>
v2.2 for GNU Emacs version 21, 1997<br>
designed by Stephen Gildea<br>
Permission is granted to make and distribute copies of this card
provided the copy-<br>
right notice and this permission notice are preserved on all
copies.<br>
For copies of the GNU Emacs manual, write to the Free Software
Foundation, Inc.,<br>
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA<br>
6<br>
</body>
</html>
